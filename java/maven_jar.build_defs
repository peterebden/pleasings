"""Extended version of the builtin maven_jar which also does licence detection."""


def maven_jar(name, id, repository=None, hash=None, hashes=None, deps=None,
              visibility=None, filename=None, sources=True, licences=None,
              exclude_paths=None, native=False, artifact_type=None, test_only=False,
              binary=False, classifier='', classifier_sources_override=''):
    """Fetches a single Java dependency from Maven.

    Args:
      name (str): Name of the output rule.
      id (str): Maven id of the artifact (eg. org.junit:junit:4.1.0)
      repository (str | list): Maven repositories to fetch deps from.
      hash (str): Hash for produced rule.
      hashes (list): List of hashes for produced rule.
      deps (list): Labels of dependencies, as usual.
      visibility (list): Visibility label.
      filename (str): Filename we attempt to download. Defaults to standard Maven name.
      sources (bool): True to download source jars as well.
      licences (list): Licences this package is subject to. If not specified they will
                       be autodetected from Maven.
      native (bool): Attempt to download a native jar (i.e. add "-linux-x86_64" etc to the URL).
      artifact_type (str): Type of artifact to download (defaults to jar but could be e.g. aar).
      test_only (bool): If True, this target can only be used by tests or other test_only rules.
      binary (bool): If True, we attempt to fetch and download an executable binary. The output
                     is marked as such. Implies native=True and sources=False.
      classifier (str): Maven classifier, allows to distinguish artifacts that were built from
                     the same POM but differ in their content.
      classifier_sources_override (str): Allows to override the classifier used to fetch the
                     source artifact.
                     e.g. logback-core-1.1.3-tests.jar and logback-core-1.1.3-test-sources.jar
    """
    if hash and hashes:
        raise ParseError('You can pass only one of hash or hashes to maven_jar')
    _maven_packages[get_base_path()][name] = id
    if not artifact_type:
        id, _, artifact_type = id.partition('@')
        artifact_type = artifact_type or 'jar'
    group, artifact, version, sources, licences = _parse_maven_artifact(id, sources, licences)
    artifact_type = '.' + artifact_type
    out_artifact_type = artifact_type
    repository = repository or CONFIG.DEFAULT_MAVEN_REPO
    repos = [repository] if isinstance(repository, str) else repository
    if classifier:
        classifier = '-' + classifier
    if binary:
        native = True
        sources = False
        artifact_type = '.exe'  # Maven always describes them this way, even for Linux :(
        out_artifact_type = ''  # But we're not peasants so we won't do the same.
    if native:
        filename = filename or '%s-%s-%s${XOS}-${XARCH}%s' % (artifact, version, classifier, artifact_type)
    else:
        filename = filename or '%s-%s%s%s' % (artifact, version, classifier, artifact_type)

    licence_rule = build_rule(
        name = name,
        tag = 'licence',
        cmd = '$TOOL -l %s:%s:%s' % (group, artifact, version),
        tools = [CONFIG.PLEASE_MAVEN_TOOL],
        post_build = lambda name, output: [add_licence(name, licence) for licence in output],
        building_description = 'Determining licence...',
    ) if not licences else None

    group = group.replace('.', '/')
    urls = ['/'.join([repo, group, artifact, version, filename]) for repo in repos]
    bin_rule  =  remote_file(
        name = name,
        _tag = 'bin',
        url = urls,
        out = name + out_artifact_type,
        hashes = hashes if hashes else [hash] if hash else None,
        licences = licences,
        deps = [licence_rule],
        exported_deps = deps,  # easiest to assume these are always exported.
        test_only = test_only,
        binary = binary,
    )
    provides = {'java': bin_rule}
    srcs = [bin_rule]

    if sources:
        if classifier_sources_override:
            classifier = '-' + classifier_sources_override
        filename = '%s-%s%s-sources.jar' % (artifact, version, classifier)
        urls = ['/'.join([repo, group, artifact, version, filename]) for repo in repos]
        src_rule = remote_file(
            name = name,
            _tag = 'src',
            url = urls,
            out = name + '_src' + artifact_type,
            licences = licences,
            test_only = test_only,
        )
        srcs.append(src_rule)

    # .aar's have an embedded classes.jar in them. Pull that out so other rules can use it.
    if artifact_type == '.aar':
        classes_rule = build_rule(
            name = name,
            tag = 'classes',
            srcs = [bin_rule],
            cmd = 'unzip $SRC classes.jar && mv classes.jar $OUT',
            outs = [name + '.jar'],
            visibility = visibility,
            licences = licences,
            requires = ['java'],
            exported_deps = deps,
            test_only=test_only,
        )
        provides = {
            'java': classes_rule,
            'android': bin_rule,
        }
        local_deps = [classes_rule]
    else:
        local_deps = None

    return filegroup(
        name = name,
        srcs = srcs,
        provides = provides,
        exported_deps=deps,  # easiest to assume these are always exported.
        deps = local_deps,  # ensure the classes_rule gets built correctly if there is one.
        labels = ['mvn:' + id],
        visibility = visibility,
        test_only=test_only,
        output_is_complete = False,
        binary = binary,
    )
