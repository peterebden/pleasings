def js_library(name, srcs, out=None, jsx=False, test_only=False, visibility=None, deps=None):
    """Defines a Javascript library rule.

    Args:
      name (str): Name of the rule.
      srcs (str): Source .js files.
      out (str): Name of the output file. Defaults to `name.js`.
      jsx (bool): True to pass the source through JSX transpilation first.
      test_only (bool): If True, can only be depended on by test rules.
      visibility (list): Visibility specification.
      deps (list): Any dependencies.
    """
    if not CONFIG.CLOSURE_COMPILER:
        raise ParseError('You must set closure-compiler in the [buildconfig] '
                         'section of your .plzconfig to use js_library rules')
    out = out or name + '.js'
    cmd = '$TOOL --in=%s --out=%s -O=%s' % (CONFIG.CLOSURE_IN_LANGUAGE, CONFIG.CLOSURE_OUT_LANGUAGE, CONFIG.CLOSURE_OPTIMISATION_LEVEL)
    if jsx:
        cmd += ' --jsx'
    return build_rule(
        name = name,
        srcs = {
            'js': srcs,
        },
        outs = {
            'js': [out],
        },
        tools = [CONFIG.CLOSURE_COMPILER],
        cmd = cmd,
    )


def jsx_library(name, srcs, out=None, test_only=False, visibility=None, deps=None):
    """Defines a Javascript library rule that uses JSX.

    This is essentially just a passthrough to js_library.

    Args:
      name (str): Name of the rule.
      srcs (str): Source .js files.
      out (str): Name of the output file. Defaults to `name.js`.
      test_only (bool): If True, can only be depended on by test rules.
      visibility (list): Visibility specification.
      deps (list): Any dependencies.
    """
    return js_library(
        name = name,
        srcs = srcs,
        out = out,
        test_only = test_only,
        visibility = visibility,
        deps = deps,
    )


def js_binary(name, srcs, out=None, visibility=None, deps=None):
    """Defines a Javascript binary rule.

    This uses Webpack to collect all the dependencies and pack them into
    a single output.

    Many TODOs remain:
      - bundles
      - incrementality
      - persistent workers
      - hot reloading?
      - etc...

    Args:
      name (str): Name of the rule.
      srcs (list): Source .js files. These are all treated as entry points.
      out (str): Name of the output file. Defaults to `name.js`.
      visibility (list): Visibility specification.
      deps (list): Any dependencies.
    """
    if not CONFIG.CLOSURE_COMPILER:
        raise ParseError('You must set closure-compiler in the [buildconfig] '
                         'section of your .plzconfig to use js_binary rules')
    out = out or name + '.js'
    return build_rule(
        name = name,
        srcs = {
            'js': srcs,
        },
        outs = {
            'js': [out],
        },
        tools = [CONFIG.CLOSURE_COMPILER],
        cmd = '$TOOL ',
    )


def js_bundle(name, srcs, out=None, visibility=None, deps=None):
    """Defines a Javascript rule that uses Webpack to build a dll / vendor bundle.

    This can be referenced by other Javascript rules using the bundles argument; they
    can't be passed directly in srcs since they're treated differently.

    Args:
      name (str): Name of the rule.
      srcs (list): Source .js files. These are all treated as entry points.
      out (str): Name of the output file. Defaults to `name.js`.
                 Note that a corresponding out-manifest.json will be created as well.
      visibility (list): Visibility specification.
      deps (list): Any dependencies.
    """
    out = out or name + '.js'
    manifest = (out[:-3] if out.endswith('.js') else out) + '-manifest.json'
    return _webpack_rule(
        name = name,
        srcs = srcs,
        out = out,
        manifest = manifest,
        visibility = visibility,
        deps = deps,
    )


def webpack_binary(name, srcs, config, webpack, visibility=None, deps=None):
    """Defines a Javascript rule that builds a Webpack bundle for compiling other rules.

    Args:
      name (str): Name of the rule.
      srcs (list): Source .js files. These are all treated as entry points.
      config (str): Webpack config file.
      webpack (str): Webpack dependency (typically a yarn_library).
      visibility (list): Visibility specification.
      deps (list): Any dependencies.
    """
    # Small nicety: handle the config not being a rule (since tools cannot be files)
    if not config.startswith(':') and not config.startswith('//'):
        config = filegroup(
            name = name,
            tag = 'config',
            srcs = [config],
        )

    cmd = 'export NODE_PATH=%s:$(dir %s); $TOOLS_NODE $(location %s)/bin/webpack.js --config $TOOLS_CONFIG' % (CONFIG.NODE_PATH, webpack, webpack)
    # TODO(peter): can we handle this inside Webpack somehow rather than this inelegant copy & cat?
    cmd += ' && mv $OUT _tmp.js && echo "#!/usr/bin/env node" > $OUT && cat _tmp.js >> $OUT'

    deps = deps or []
    return build_rule(
        name = name,
        srcs = {'js': srcs},
        outs = {'js': [name + '.js']},
        cmd = cmd,
        tools = {
            'node': [CONFIG.NODE_TOOL],
            'config': [config],
        },
        # Note that webpack has to be a dep not a tool so that we get its dependencies too.
        deps = deps + [webpack],
        requires = ['js'],
        visibility = visibility,
        needs_transitive_deps = True,
        output_is_complete = True,
        binary = True,
    )


def _webpack_rule(name, srcs, bundles=None, out=None, manifest=None, binary=False, shebang='',
                  visibility=None, deps=None):
    """Internal function for the various webpack-calling rules above."""

    # Because we identify specific outs from the bundle rules, they have to be actual rules and
    # can't just be source files. Detect here because the errors can be a bit obtuse later.
    bundles = bundles or []
    if any(bundle for bundle in bundles if not bundle.startswith(':') and not bundle.startswith('/')):
        raise ParseError('bundles argument must be a js_bundle rule or something similar')

    cmd = 'export NODE_PATH=%s; $TOOLS_NODE $TOOLS_WEBPACK' % CONFIG.NODE_PATH
    if binary:
        # TODO(peter): can we handle this inside Webpack somehow rather than this inelegant copy & cat?
        cmd += ' && mv $OUTS_JS _tmp.js && echo "%s" > $OUTS_JS && cat _tmp.js >> $OUTS_JS' % shebang

    return build_rule(
        name = name,
        srcs = {
            'js': srcs,
            'dll': [bundle + '|js' for bundle in bundles],
            'manifest': [bundle + '|manifest' for bundle in bundles],
        },
        outs = {
            'js': [out or name + '.js'],
            'manifest': [manifest],
        },
        cmd = cmd,
        tools = {
            'node': [CONFIG.NODE_TOOL],
            'webpack': [CONFIG.WEBPACK_TOOL],
        },
        requires = ['js'],
        visibility = visibility,
        deps = deps,
        needs_transitive_deps = True,
        output_is_complete = True,
        binary = binary,
    )


def _rollup_rule(name, srcs, out=None, visibility=None, deps=None):
    """Internal function for the various webpack-calling rules above."""
    if not CONFIG.ROLLUP_TOOL:
        raise ParseError('You must set rollup-tool in the [buildconfig] section of '
                         'your .plzconfig file to use js_binary rules')

    out = out or name + '.js'
    return build_rule(
        name = name,
        srcs = srcs,
        outs = {
            'js': [out],
            'map': [out + '.map'],
        },
        cmd = '$TOOLS_NODE $TOOLS_ROLLUP',
        tools = {
            'node': [CONFIG.NODE_TOOL],
            'rollup': [CONFIG.ROLLUP_TOOL],
        },
        requires = ['js'],
        visibility = visibility,
        deps = deps,
        needs_transitive_deps = True,
        output_is_complete = True,
        binary = True,
    )


def build_rollup(name, main, config, rollup, visibility=None, deps=None):
    """Helper rule to bootstrap a binary using Rollup.

    Args:
      name (str): Name of the rule
      main (str): JS file that is the entry point
      config (str): Rollup config file to define how to build it
      rollup (str): Rule providing a stock rollup install (typically a yarn_library)
      visibility (list): Visibility specification.
      deps (list): Any dependencies.
    """
    # For some weird reason this only works if it is in a directory literally called node_modules?!?
    cmd = ' && '.join([
        'mv $(dir %s) node_modules' % rollup,
        'export NODE_PATH="./node_modules"',
        '$TOOL node_modules/rollup/bin/rollup --config $SRCS_CONFIG $SRCS_MAIN -o $OUT',
    ])
    deps = deps or []
    return build_rule(
        name = name,
        srcs = {
            'main': [main],
            'config': [config],
        },
        outs = {'js': [name + '.js']},
        tools = [CONFIG.NODE_TOOL],
        cmd = cmd,
        deps = deps + [rollup],
        requires = ['js'],
        visibility = visibility,
        binary = True,
        needs_transitive_deps = True,
        output_is_complete = True,
    )


# Set these so others can override them using package()
CONFIG.setdefault('NODE_TOOL', 'node')
CONFIG.setdefault('NODE_PATH', '$TMP_DIR:$TMP_DIR/third_party/js')
CONFIG.setdefault('WEBPACK_TOOL', '//third_party/js:webpack')
CONFIG.setdefault('ROLLUP_TOOL', '')
CONFIG.setdefault('CLOSURE_COMPILER', '')
CONFIG.setdefault('CLOSURE_IN_LANGUAGE', 'ES_2015')
CONFIG.setdefault('CLOSURE_OUT_LANGUAGE', 'ES5')
CONFIG.setdefault('CLOSURE_OPTIMISATION_LEVEL', 'SIMPLE')
